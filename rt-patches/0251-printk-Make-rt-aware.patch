From b00a1c7df1a726c92c5431a9909d750a46890356 Mon Sep 17 00:00:00 2001
From: Thomas Gleixner <tglx@linutronix.de>
Date: Wed, 19 Sep 2012 14:50:37 +0200
Subject: [PATCH 251/337] printk: Make rt aware

Drop the lock before calling the console driver and do not disable
interrupts while printing to a serial console.

Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
---
 kernel/printk/printk.c | 30 +++++++++++++++++++++++++++---
 1 file changed, 27 insertions(+), 3 deletions(-)

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index ea72844..d91263b 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1629,6 +1629,7 @@ static void call_force_console_drivers(const char *force_text,
 	if (!console_drivers)
 		return;
 
+	migrate_disable();
 	for_each_console(con) {
 		if (exclusive_console && con != exclusive_console)
 			continue;
@@ -1643,6 +1644,7 @@ static void call_force_console_drivers(const char *force_text,
 		if (con->flags & CON_FORCE_LEVEL)
 			con->write(con, force_text, force_len);
 	}
+	migrate_enable();
 }
 
 /*
@@ -1661,6 +1663,7 @@ static void call_console_drivers(int level,
 	if (!console_drivers)
 		return;
 
+	migrate_disable();
 	for_each_console(con) {
 		if (exclusive_console && con != exclusive_console)
 			continue;
@@ -1680,6 +1683,7 @@ static void call_console_drivers(int level,
 		else
 			con->write(con, text, len);
 	}
+	migrate_enable();
 }
 
 /*
@@ -1992,13 +1996,23 @@ asmlinkage int vprintk_emit(int facility, int level,
 
 	/* If called from the scheduler, we can not call up(). */
 	if (!in_sched) {
+		int may_trylock = 1;
+
 		lockdep_off();
+#ifdef CONFIG_PREEMPT_RT_FULL
+		/*
+		 * we can't take a sleeping lock with IRQs or preeption disabled
+		 * so we can't print in these contexts
+		 */
+		if (!(preempt_count() == 0 && !irqs_disabled()))
+			may_trylock = 0;
+#endif
 		/*
 		 * Try to acquire and then immediately release the console
 		 * semaphore.  The release will print out buffers and wake up
 		 * /dev/kmsg and syslog() users.
 		 */
-		if (console_trylock())
+		if (may_trylock && console_trylock())
 			console_unlock();
 		lockdep_on();
 	}
@@ -2395,8 +2409,12 @@ static void console_cont_flush(char *text, size_t size)
 
 	cons = cont.cons;
 	len = cont_print_text(text, size);
+#ifdef CONFIG_PREEMPT_RT_FULL
+	raw_spin_unlock_irqrestore(&logbuf_lock, flags);
+#else
 	raw_spin_unlock(&logbuf_lock);
 	stop_critical_timings();
+#endif
 	call_console_drivers(cont.level, NULL, 0, text, len);
 
 	/* Add prefix in case console is with CON_FORCE_LEVEL */
@@ -2413,9 +2431,10 @@ static void console_cont_flush(char *text, size_t size)
 	} else {
 		call_force_console_drivers(text, len);
 	}
-
+#ifndef CONFIG_PREEMPT_RT_FULL
 	start_critical_timings();
 	local_irq_restore(flags);
+#endif
 	return;
 out:
 	raw_spin_unlock_irqrestore(&logbuf_lock, flags);
@@ -2544,6 +2563,11 @@ void console_unlock(void)
 		console_idx = log_next(console_idx);
 		console_seq++;
 		console_prev = msg->flags;
+#ifdef CONFIG_PREEMPT_RT_FULL
+		raw_spin_unlock_irqrestore(&logbuf_lock, flags);
+		call_console_drivers(level, ext_text, ext_len, text, len);
+		call_force_console_drivers(force_text, force_len);
+#else
 		raw_spin_unlock(&logbuf_lock);
 
 		stop_critical_timings();	/* don't trace print latency */
@@ -2551,7 +2575,7 @@ void console_unlock(void)
 		call_force_console_drivers(force_text, force_len);
 		start_critical_timings();
 		local_irq_restore(flags);
-
+#endif
 		if (do_cond_resched)
 			cond_resched();
 	}
-- 
1.9.1

