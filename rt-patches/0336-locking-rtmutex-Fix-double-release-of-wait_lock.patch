From 42c5590148adeb393e6cd26d950f85ae50a41340 Mon Sep 17 00:00:00 2001
From: abhijit <abhijit@nvidia.com>
Date: Thu, 30 Nov 2017 10:26:38 +0530
Subject: [PATCH 336/337] locking/rtmutex: Fix double release of wait_lock

rtmutex wait_lock was released twice in case pi_blocked_on is already
set by the task in rt_mutex_start_proxy_lock. This was leading to crash
later on in futex_wait path because of wrong value of preempt_count().
We were hitting VM_BUG_ON(in_interrupt()) in gup code in case of crash.

Bug 200343182

Change-Id: Iabe4c17a1f05a3e5dbaf9955f2efc03ff914bd2b
Signed-off-by: Abhijit <abhijit@nvidia.com>
---
 kernel/locking/rtmutex.c | 1 -
 1 file changed, 1 deletion(-)

diff --git a/kernel/locking/rtmutex.c b/kernel/locking/rtmutex.c
index 78a6c4a..9fb3647 100644
--- a/kernel/locking/rtmutex.c
+++ b/kernel/locking/rtmutex.c
@@ -2300,7 +2300,6 @@ int __rt_mutex_start_proxy_lock(struct rt_mutex *lock,
 	raw_spin_lock(&task->pi_lock);
 	if (task->pi_blocked_on) {
 		raw_spin_unlock(&task->pi_lock);
-		raw_spin_unlock_irq(&lock->wait_lock);
 		return -EAGAIN;
 	}
 	task->pi_blocked_on = PI_REQUEUE_INPROGRESS;
-- 
1.9.1

